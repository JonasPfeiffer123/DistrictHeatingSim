import sys
import random
from PyQt5.QtWidgets import (QApplication, QMainWindow, QGraphicsScene, 
                             QGraphicsView, QGraphicsEllipseItem, QGraphicsPathItem, QGraphicsLineItem,
                             QVBoxLayout, QPushButton, QGraphicsItem, QWidget, QHBoxLayout, QGraphicsRectItem, QLabel)
from PyQt5.QtCore import Qt, QPointF, QRectF, pyqtSignal, QObject, QLineF
from PyQt5.QtGui import QPen, QColor, QPainterPath

class CustomGraphicsScene(QGraphicsScene):
    # Signal to emit mouse position updates
    mouse_position_changed = pyqtSignal(float, float)

    def __init__(self, x, y, width, height, parent=None):
        super().__init__(x, y, width, height, parent)
        self.setSceneRect(x, y, width, height)

    def mouseMoveEvent(self, event):
        """Handle mouse move events in the scene"""
        mouse_position = event.scenePos()  # Get mouse position relative to the scene
        x = mouse_position.x()
        y = mouse_position.y()
        self.mouse_position_changed.emit(x, y)  # Emit signal with the new coordinates
        super().mouseMoveEvent(event)

class SchematicWindow(QMainWindow):
    GRID_SIZE = 5  # Define grid size for snapping

    def __init__(self):
        super().__init__()

        # Set up main window
        self.setWindowTitle('Complex Heat Generator Schematic')
        self.setGeometry(100, 100, 1000, 800)

        self.centralWidget = QWidget()
        self.setCentralWidget(self.centralWidget)

        layout = QHBoxLayout(self.centralWidget)

        # Graphics view and scene
        self.scene = CustomGraphicsScene(0, 0, 900, 700)  # Use custom scene
        self.scene.setBackgroundBrush(QColor(240, 240, 240))  # Light gray background
        self.view = QGraphicsView(self.scene)
        layout.addWidget(self.view)

        # Button panel
        button_layout = QVBoxLayout()
        self.add_solar_button = QPushButton("Add Solar")
        self.add_chp_button = QPushButton("Add CHP")
        self.add_solar_storage_button = QPushButton("Add Solar + Storage")
        self.add_chp_storage_button = QPushButton("Add CHP + Storage")
        self.add_consumer_button = QPushButton("Add Consumer")
        button_layout.addWidget(self.add_solar_button)
        button_layout.addWidget(self.add_chp_button)
        button_layout.addWidget(self.add_solar_storage_button)
        button_layout.addWidget(self.add_chp_storage_button)
        button_layout.addWidget(self.add_consumer_button)

        # Mouse coordinate label
        self.mouse_label = QLabel("Mouse Coordinates: x = 0, y = 0")
        button_layout.addWidget(self.mouse_label)

        # Mouse coordinate signal connection
        self.scene.mouse_position_changed.connect(self.update_mouse_label)

        layout.addLayout(button_layout)

        # Button signals
        self.add_solar_button.clicked.connect(self.add_solar)
        self.add_chp_button.clicked.connect(self.add_chp)
        self.add_solar_storage_button.clicked.connect(self.add_solar_storage)
        self.add_chp_storage_button.clicked.connect(self.add_chp_storage)
        self.add_consumer_button.clicked.connect(self.add_consumer)

        # Variables to keep track of objects and numbering
        self.generators = []
        self.storage_units = []
        self.pipes = []
        self.consumer = None
        self.generator_counter = 0
        self.storage_counter = 0

    def update_mouse_label(self, x, y):
        """Update the mouse label when the mouse moves in the scene"""
        self.mouse_label.setText(f"Mouse Coordinates: x = {x:.1f}, y = {y:.1f}")

    def snap_to_grid(self, position):
        """Snap the given position to the nearest grid point"""
        x = round(position.x() / self.GRID_SIZE) * self.GRID_SIZE
        y = round(position.y() / self.GRID_SIZE) * self.GRID_SIZE
        return QPointF(x, y)

    def add_solar(self):
        """Add a solar heat generator"""
        position = self.get_random_position()
        position = self.snap_to_grid(position)  # Snap the position to the grid
        generator = ComplexGenerator(position, 'Solar', QColor('yellow'))
        generator.create_connection_points()  # Verbindungspunkte erstellen
        self.scene.addItem(generator)
        self.generators.append(generator)
        self.generator_counter += 1
        self.add_label(generator, f'Solar {self.generator_counter}')
        
        if self.consumer:
            self.connect_to_consumer(generator)

    def add_chp(self):
        """Add a CHP generator"""
        position = self.get_random_position()
        position = self.snap_to_grid(position)  # Snap the position to the grid
        generator = ComplexGenerator(position, 'CHP', QColor('blue'))
        generator.create_connection_points()  # Verbindungspunkte erstellen
        self.scene.addItem(generator)
        self.generators.append(generator)
        self.generator_counter += 1
        self.add_label(generator, f'CHP {self.generator_counter}')
        
        if self.consumer:
            self.connect_to_consumer(generator)

    def add_storage(self, position=None):
        """Add a storage unit"""
        if position is None:
            position = self.get_random_position()
            position = self.snap_to_grid(position)  # Snap the position to the grid
        storage = ComplexGenerator(position, 'Storage', QColor('purple'), shape='rect')
        storage.create_connection_points()  # Verbindungspunkte erstellen
        self.scene.addItem(storage)
        self.storage_units.append(storage)
        self.storage_counter += 1
        self.add_label(storage, f'Storage {self.storage_counter}')
        return storage

    def add_solar_storage(self):
        """Add Solar + Storage with fixed storage position to the right of the generator"""
        # Add the generator first
        position = self.get_random_position()
        position = self.snap_to_grid(position)  # Snap the position to the grid
        generator = ComplexGenerator(position, 'Solar', QColor('yellow'))
        generator.create_connection_points()  # Verbindungspunkte erstellen
        self.scene.addItem(generator)
        self.generators.append(generator)
        self.generator_counter += 1
        self.add_label(generator, f'Solar {self.generator_counter}')

        # Position the storage to the right of the generator
        storage_position = QPointF(position.x() + 100, position.y())  # Fixed distance of 100 units to the right
        storage_position = self.snap_to_grid(storage_position)
        storage = ComplexGenerator(storage_position, 'Storage', QColor('purple'), shape='rect')
        storage.create_connection_points()  # Verbindungspunkte erstellen
        self.scene.addItem(storage)
        self.storage_units.append(storage)
        self.storage_counter += 1
        self.add_label(storage, f'Storage {self.storage_counter}')

        # Connect the generator to the storage only
        self.connect_generator_to_storage(generator, storage)

        # Connect the storage to the consumer (not the generator directly)
        if self.consumer:
            self.connect_storage_to_consumer(storage)

    def add_chp_storage(self):
        """Add CHP + Storage with fixed storage position to the right of the generator"""
        # Add the generator first
        position = self.get_random_position()
        position = self.snap_to_grid(position)  # Snap the position to the grid
        generator = ComplexGenerator(position, 'CHP', QColor('blue'))
        generator.create_connection_points()  # Verbindungspunkte erstellen
        self.scene.addItem(generator)
        self.generators.append(generator)
        self.generator_counter += 1
        self.add_label(generator, f'CHP {self.generator_counter}')

        # Position the storage to the right of the generator
        storage_position = QPointF(position.x() + 100, position.y())  # Fixed distance of 100 units to the right
        storage_position = self.snap_to_grid(storage_position)
        storage = ComplexGenerator(storage_position, 'Storage', QColor('purple'), shape='rect')
        storage.create_connection_points()  # Verbindungspunkte erstellen
        self.scene.addItem(storage)
        self.storage_units.append(storage)
        self.storage_counter += 1
        self.add_label(storage, f'Storage {self.storage_counter}')

        # Connect the generator to the storage only
        self.connect_generator_to_storage(generator, storage)

        # Connect the storage to the consumer (not the generator directly)
        if self.consumer:
            self.connect_storage_to_consumer(storage)

    def add_consumer(self):
        """Add the consumer (network)"""
        if self.consumer is None:
            position = self.get_random_position()
            position = self.snap_to_grid(position)  # Snap the position to the grid
            self.consumer = ConsumerItem(position, 'Consumer', QColor('green'))
            self.consumer.create_connection_points()  # Verbindungspunkte erstellen
            self.scene.addItem(self.consumer)
            self.add_label(self.consumer, 'Wärmenetz')
            
            # Optionally connect each generator to the consumer
            for generator in self.generators:
                # Check if the generator is already connected to a storage unit
                connected_to_storage = any(
                    storage for storage in self.storage_units if self.is_connected(generator, storage)
                )
                
                if not connected_to_storage:
                    # If the generator is not connected to a storage unit, connect it directly to the consumer
                    self.connect_to_consumer(generator)
                else:
                    # If the generator is connected to a storage unit, connect the storage to the consumer
                    for storage in self.storage_units:
                        if self.is_connected(generator, storage):
                            self.connect_storage_to_consumer(storage)

    def get_random_position(self):
        """Generate a random position within the scene that doesn't overlap with existing items"""
        while True:
            x = random.randint(50, 850)  # Adjust these values to fit within the scene's boundaries
            y = random.randint(50, 650)
            position = QPointF(x, y)
            position = self.snap_to_grid(position)  # Ensure position is snapped to the grid
            if not self.is_overlapping(position):
                return position

    def is_overlapping(self, position):
        """Check if a new item at the given position would overlap with existing items"""
        new_item_rect = QRectF(position.x() - 30, position.y() - 30, 60, 60)  # Adjust based on item size
        for item in self.scene.items():
            if isinstance(item, QGraphicsRectItem):
                if item.sceneBoundingRect().intersects(new_item_rect):
                    return True
        return False

    def add_label(self, item, text):
        """Add a label under the item with a specific text"""
        label = self.scene.addText(text)
        label.setPos(item.pos().x() - 20, item.pos().y() + 40)  # Place label under the item
        item.label = label  # Store the label reference in the item

    def is_connected(self, generator, storage):
        """Check if a generator is connected to a storage unit"""
        for pipe in self.pipes:
            # Check if the connection points of the pipe are connected to the given generator and storage
            if (pipe.point1.parentItem() == generator and pipe.point2.parentItem() == storage) or \
            (pipe.point1.parentItem() == storage and pipe.point2.parentItem() == generator):
                return True
        return False

    def connect_items(self, item1, item2):
        """Connect two items (generator, storage, or consumer) using their connection points"""
        if item1.connection_points and item2.connection_points:
            # Item 1: Speicher oder Erzeuger
            if item1.item_type == 'Storage':
                # Speicher: Obere Verbindung für Vorlauf und untere für Rücklauf
                point1_supply = item1.connection_points[1]  # 1: Obere rechte Verbindung für Vorlauf zum Netz
                point1_return = item1.connection_points[3]  # 3: Untere rechte Verbindung für Rücklauf zum Netz
            else:
                # Erzeuger oder Verbraucher: Verwende rechte Verbindung für Vorlauf und linke für Rücklauf
                point1_supply = item1.connection_points[0]  # 0: Obere Verbindung für Vorlauf
                point1_return = item1.connection_points[1]  # 1: Untere Verbindung für Rücklauf

            # Item 2: Speicher oder Verbraucher
            if item2.item_type == 'Storage':
                # Speicher: Obere Verbindung für Vorlauf und untere für Rücklauf
                point2_supply = item2.connection_points[0]  # Obere linke Verbindung für Vorlauf zum Speicher
                point2_return = item2.connection_points[2]  # Untere linke Verbindung für Rücklauf zum Speicher
            else:
                # Verbraucher oder Erzeuger: Verwende linke Verbindung für Rücklauf und rechte für Vorlauf
                point2_supply = item2.connection_points[0]  # Rechte Verbindung für Vorlauf
                point2_return = item2.connection_points[1]  # Linke Verbindung für Rücklauf

            # Red supply pipe (Vorlauf)
            supply_pipe = Pipe(point1_supply, point2_supply, color=Qt.red)
            self.scene.addItem(supply_pipe)
            self.pipes.append(supply_pipe)

            # Blue return pipe (Rücklauf)
            return_pipe = Pipe(point1_return, point2_return, color=Qt.blue)
            self.scene.addItem(return_pipe)
            self.pipes.append(return_pipe)
        else:
            print("Error: One or both items have no connection points.")

    def connect_to_consumer(self, generator):
        """Connect generator to consumer if no storage is used"""
        if self.consumer:
            self.connect_items(generator, self.consumer)

    def connect_storage_to_consumer(self, storage):
        """Connect storage to consumer with a supply and return line"""
        if self.consumer:
            self.connect_items(storage, self.consumer)

    def connect_generator_to_storage(self, generator, storage):
        """Connect generator to storage with a supply and return line"""
        self.connect_items(generator, storage)

class ComponentItem(QGraphicsRectItem):
    def __init__(self, position, item_type, color, shape='rect'):
        """Create a general visual representation of a component (generator, consumer, etc.)"""
        if shape == 'rect':
            super().__init__(-30, -15, 60, 30)  # Rectangular shape
        else:
            super().__init__(-20, -20, 40, 40)  # Circular shape by default
        
        self.setBrush(color)
        self.setFlag(QGraphicsItem.ItemIsMovable)
        self.setFlag(QGraphicsItem.ItemSendsGeometryChanges)
        self.setFlag(QGraphicsItem.ItemIsSelectable)
        self.item_type = item_type
        self.setPos(position)
        self.label = None  # Placeholder for label reference

        # Placeholder for connection points (ports)
        self.connection_points = []

    def create_connection_points(self):
        """Create connection points (ports) for the item"""
        if self.item_type == 'Storage':
            # Storage has 4 connection points: top-left, top-right, bottom-left, bottom-right
            self.connection_points.append(self.create_connection_point(0, 0, direction='left', color=Qt.red))    # Top-left
            self.connection_points.append(self.create_connection_point(1, 0, direction='right', color=Qt.red))   # Top-right
            self.connection_points.append(self.create_connection_point(0, 1, direction='left', color=Qt.blue))    # Bottom-left
            self.connection_points.append(self.create_connection_point(1, 1, direction='right', color=Qt.blue))   # Bottom-right
        else:
            # Generators and consumers have 2 connection points: left and right
            self.connection_points.append(self.create_connection_point(0.5, 0, direction='up', color=Qt.red))  # Top (middle)
            self.connection_points.append(self.create_connection_point(0.5, 1, direction='down', color=Qt.blue))  # Bottom (middle)
            print(f"Connection points created for {self.item_type}: {self.connection_points}")

    def create_connection_point(self, x_offset, y_offset, direction, color):
        """Helper method to create a connection point at a relative position based on the bounding rectangle."""
        print(f"Creating connection point with offsets x: {x_offset}, y: {y_offset}")
        point = ConnectionPoint(self, x_offset, y_offset, direction, color)
        print(point.x(), point.y())
        if self.scene():  # Only add if scene exists
            print(f"Adding connection point to scene: {point.line().p1()}, {point.line().p2()}")
            self.scene().addItem(point)
        return point

    def itemChange(self, change, value):
        """Update connected pipes and label when the component moves."""
        if change == QGraphicsItem.ItemPositionChange:
            # Snap the item to the grid when it's moved
            value = window.snap_to_grid(value)

            if self.scene():  # Check if the item is in a scene
                # Update all pipes in the scene
                for pipe in self.scene().items():
                    if isinstance(pipe, Pipe):
                        pipe.update_path()  # Update the path of all pipes

                # Update the position of the label if it exists
                if self.label:
                    self.label.setPos(value.x() - 20, value.y() + 40)

                # Update all connection points to reflect the new position
                for point in self.connection_points:
                    point.update_position()

        return super().itemChange(change, value)

class ComplexGenerator(ComponentItem):
    def __init__(self, position, generator_type, color, shape='ellipse'):
        """Create a more complex visual representation of a generator"""
        super().__init__(position, generator_type, color, shape)

class ConsumerItem(ComponentItem):
    def __init__(self, position, consumer_type, color):
        """Create a visual representation of a consumer (Wärmenetz)"""
        super().__init__(position, consumer_type, color)

class ConnectionPoint(QGraphicsLineItem):
    def __init__(self, parent, x_offset, y_offset, direction, color):
        """Create a connection point as a short line extending from the parent item."""
        self.parent = parent
        self.x_offset = x_offset
        self.y_offset = y_offset
        self.direction = direction  # Direction of the line extension (up, down, left, right)
        self.color = color

        # Create the line as a QGraphicsLineItem
        super().__init__()
        self.setParentItem(parent)  # Attach to the parent item (Generator, Storage, etc.)

        # Set the pen for the line (its color and thickness)
        self.setPen(QPen(self.color, 3))

        # Position the connection point and create its extension line
        self.update_position()

    def update_position(self):
        """Update the position of the connection point relative to the parent item and its extension line"""
        bounding_rect = self.parentItem().boundingRect()

        # Calculate the new position relative to the parent's local coordinate system
        local_x = bounding_rect.x() + bounding_rect.width() * self.x_offset
        local_y = bounding_rect.y() + bounding_rect.height() * self.y_offset

        # Transform the local coordinates to scene coordinates
        #scene_pos = self.parentItem().mapToScene(QPointF(local_x, local_y))

        # Transform the local coordinates to scene coordinates
        scene_pos = QPointF(local_x, local_y)

        # Set the start of the line to the position of this connection point
        line_start = scene_pos

        # Determine the direction of the line and set the end point
        if self.direction == 'up':
            line_end = QPointF(line_start.x(), line_start.y() - 20)
        elif self.direction == 'down':
            line_end = QPointF(line_start.x(), line_start.y() + 20)
        elif self.direction == 'left':
            line_end = QPointF(line_start.x() - 20, line_start.y())
        elif self.direction == 'right':
            line_end = QPointF(line_start.x() + 20, line_start.y())

        # Set the line's geometry based on the calculated start and end points
        self.setLine(QLineF(line_start, line_end))

    def get_end_point(self):
        """Return the end point of the connection line (for pipe connections)."""
        return self.parentItem().mapToScene(self.line().p2())

class Pipe(QGraphicsPathItem):
    def __init__(self, point1, point2, color=Qt.red):
        """Create a flexible pipe (supply/return) between generator and consumer"""
        super().__init__()
        self.point1 = point1
        self.point2 = point2
        self.color = color  # Color for the pipe (red for supply, blue for return)

        # Set the pen for the pipe, making it thicker and colored
        self.setPen(QPen(self.color, 3))  # Set line color and thickness

        # Ensure the pipe is added to the scene first
        if point1.scene() is not None:
            point1.scene().addItem(self)  # Add the pipe to the scene

        # Now it's safe to call update_path since the pipe is in the scene
        self.update_path()

    def update_path(self):
        """Update the pipe path based on the new position of the generator and consumer, with automatic right-angled turns and collision avoidance."""
        start_pos = self.point1.get_end_point()  # Get the end point of the connection point
        end_pos = self.point2.get_end_point()    # Get the end point of the connection point

        # Create a path from start to end, avoiding diagonal lines
        self.path = QPainterPath(start_pos)

        # Calculate a right-angle turn: Go horizontally first, then vertically (or vice versa)
        if abs(start_pos.x() - end_pos.x()) > abs(start_pos.y() - end_pos.y()):
            intermediate_point = QPointF(end_pos.x(), start_pos.y())
        else:
            intermediate_point = QPointF(start_pos.x(), end_pos.y())

        # Check for collisions at the intermediate point and adjust the path
        if self.check_collision(intermediate_point):
            if abs(start_pos.x() - end_pos.x()) > abs(start_pos.y() - end_pos.y()):
                # Add a second right-angle turn if collision is detected horizontally
                intermediate_point = QPointF(start_pos.x(), start_pos.y() + 50)  # Go down/up by 50 units
                avoidance_point = QPointF(end_pos.x(), intermediate_point.y())
                self.path.lineTo(intermediate_point)
                self.path.lineTo(avoidance_point)
            else:
                # Add a second right-angle turn if collision is detected vertically
                intermediate_point = QPointF(start_pos.x() + 50, start_pos.y())  # Go right/left by 50 units
                avoidance_point = QPointF(intermediate_point.x(), end_pos.y())
                self.path.lineTo(intermediate_point)
                self.path.lineTo(avoidance_point)
        else:
            # If no collision, go directly through the intermediate point
            self.path.lineTo(intermediate_point)

        # Add the final segment to the end position
        self.path.lineTo(end_pos)

        # Apply the updated path to the Pipe
        self.setPath(self.path)

    def check_collision(self, point):
        """Check if the given point collides with any item (generator, consumer, storage)"""
        # Only check for collisions if the pipe is part of a scene
        if self.scene() is None:
            return False

        for item in self.scene().items():
            if isinstance(item, ComponentItem):
                if item.contains(item.mapFromScene(point)):
                    return True
        return False

if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = SchematicWindow()
    window.show()
    sys.exit(app.exec_())
